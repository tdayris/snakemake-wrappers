.. _`tximport_deseq2`:

TXIMPORT_DESEQ2
===============

Import counts with tximport and run DESeq2


Example
-------

This meta-wrapper can be used by integrating the following into your workflow:

.. code-block:: python

    default_tximport_deseq2_config = {
        "gtf": "annotation.gtf",
        "design": "design.tsv",
        "output_prefixes": ["DGE"],
        "comparison_levels": [["Cond", "A", "B"]],
        "samples_per_prefixes": {"DGE": ["S1", "S2", "S3", "S4"]}
    }

    try:
        if config == dict():
            config = default_tximport_deseq2_config
    except NameError:
        config = default_tximport_deseq2_config

    # Requires a list of constrasts as defined in DESeq2:
    # [factor, ref, test]
    # This list should be named: comparison_levels

    # Requires a list of comparison names, in the same order as the previous levels
    # It should be named: output_prefixes

    contrasts = dict(zip(
        config["output_prefixes"],
        config["comparison_levels"]
    ))

    batch_effect = any(
        level[0] == "BatchEffect" for level in config["comparison_levels"]
    )


    ###############
    ### Reports ###
    ###############

    normalized_counts_rst = (
        "reports/normalized_counts.rst"
        if os.path.exists("reports/normalized_counts.rst")
        else None
    )

    deseq2_rst = (
        "reports/deseq2_tsv.rst"
        if os.path.exists("reports/deseq2_tsv.rst")
        else None
    )


    ###################
    ### Readability ###
    ###################


    rule rbt_csv_report:
        input:
            "deseq2/{comparison}/{comparison}.{content}.tsv"
        output:
            directory("deseq2/{comparison}/{comparison}.{content}/")
        message: "Making DESeq2 results readable and searchable"
        threads: 1
        resources:
            mem_mb=lambda wildcards, attempt: attempt * 1024,
            time_min=lambda wildcards, attempt: attempt * 5
        log:
            "logs/rbt/csv-report/{comparison}.{content}.log"
        params:
            '--separator "\\t" '
            '--sort-column stat_change '
            '--sort-order ascending '
            '--rows-per-page 50'
        wrapper:
            "bio/rbt/csvreport"


    rule deseq2_readable:
        input:
            tsv = "deseq2/{comparison}/wald.{comparison}.tsv",
            gene2gene = "tximport/gene2gene.tsv"
        output:
            fc_sig = temp("deseq2/{comparison}/{comparison}.DE_genes_with_FC.tsv"),
            padj_sig = temp("deseq2/{comparison}/{comparison}.DE_genes_with_padj.tsv"),
            complete = temp("deseq2/{comparison}/{comparison}.complete_results.tsv")
        message:
            "Annotating output results for {wildcards.comparison}"
        threads: 1
        resources:
            mem_mb = (
                lambda wildcards, attempt: min(attempt * 1024, 10240)
            ),
            time_min = (
                lambda wildcards, attempt: min(attempt * 20, 200)
            )
        log:
            "logs/deseq2/readable/{comparison}.log"
        wrapper:
            "bio/pandas/deseq2_to_gseaapp"


    ##############
    ### DESeq2 ###
    ##############

    """
    This rule performs the size factor and dispersions estimations as well as the
    wald test.
    """
    rule deseq2:
        input:
            dds="deseq2/{comparison}/dds.{comparison}.RDS"
        output:
            rds=temp("deseq2/{comparison}/wald.{comparison}.RDS"),
            deseq2_tsv=report(
                "deseq2/{comparison}/wald.{comparison}.tsv",
                caption=deseq2_rst,
                category="DESeq2 results"
            ),
            normalized_counts=report(
                "deseq2/{comparison}/dst.{comparison}.tsv",
                caption=normalized_counts_rst ,
                category="Normalized counts"
            ),
            dst=temp("deseq2/{comparison}/dst.{comparison}.RDS"),
            intermediar_values="deseq2/{comparison}/mcols.{comparison}.tsv",
            assays_mu="deseq2/{comparison}/assays.mu.{comparison}.tsv",
            filter_theta="deseq2/{comparison}/filter.theta.{comparison}.tsv",
            metadata="deseq2/{comparison}/metadata.{comparison}.tsv"
        message: "Running DESeq2 analysis for {wildcards.comparison}"
        threads: 1
        resources:
            mem_mb=lambda wildcards, attempt: attempt * 2048,
            time_min=lambda wildcards, attempt: attempt * 60
        params:
            contrast=lambda wildcards: contrasts[wildcards.comparison],
            #name=lambda wildcards: "_".join([
            #   contrasts[wildcards.comparison][0],
            #   contrasts[wildcards.comparison][1],
            #   "vs",
            #   contrasts[wildcards.comparison][2]
            #])
        log:
            "logs/deseq2/deseq/{comparison}.log"
        wrapper:
            "bio/deseq2/DESeq"


    """
    This rule formats counts for DESeq2. The design matrix and its corresponding
    formula are included.
    """
    rule deseq2_dataset_from_tximport:
        input:
            tximport="tximport/txi.{comparison}.RDS",
            coldata="deseq2/designs/{comparison}.tsv",
        output:
            dds=temp("deseq2/{comparison}/dds.{comparison}.RDS")
        message: "Formatting {wildcards.comparison} counts for DESeq2",
        threads: 1
        resources:
            mem_mb=lambda wildcards, attempt: min(attempt * 3072, 20480),
            time_min=lambda wildcards, attempt: attempt * 45
        params:
            design=lambda wildcards: (
                f"~{contrasts[wildcards.comparison][0]}"
                if (batch_effect is False) or wildcards.comparison == "BatchEffect"
                else f"~BatchEffect+{contrasts[wildcards.comparison][0]}"
            ),
            levels=lambda wildcards: contrasts[wildcards.comparison][1:],
            factor=lambda wildcards: contrasts[wildcards.comparison][0],
            ref_level=lambda wildcards: contrasts[wildcards.comparison][-1],
            remove_zeros=True,
            count_filter=5
        log:
            "logs/deseq2/deseq2_dataset_from_tximport/{comparison}.log"
        wrapper:
            "bio/deseq2/DESeqDataSetFromTximport"


    ##########################
    ### Counts aggregation ###
    ##########################

    """
    This rule imports counts from tables to R data object. Its memory requirements
    are linked to the number of samples
    """
    rule tximport:
        input:
            quant=lambda wildcards: expand(
                "salmon/pseudo_mapping/{sample}/quant.sf",
                sample=config["samples_per_prefixes"][wildcards.comparison]
            ),
            tx_to_gene="tximport/tx2gene.tsv"
        output:
            txi=temp("tximport/txi.{comparison}.RDS")
        message: "Importing counts in DESeq2 for {wildcards.comparison}"
        threads: 1
        resources:
            mem_mb=lambda wildcards, input: len(input.quant) * 1024,
            time_min=lambda wildcards, attempt: attempt * 45
        params:
            extra=config.get(
                "tximport_extra",
                "type='salmon', ignoreTxVersion=TRUE, ignoreAfterBar=TRUE"
            )
        log:
            "logs/tximport/{comparison}.log"
        wrapper:
            "bio/tximport"


    """
    This rule build the conversion table from transcript to genes and their names.
    """
    rule tx_to_gene_deseq2:
        input:
            gtf=config["gtf"]
        output:
            tx2gene_small=temp("tximport/tx2gene.tsv"),
            tx2gene_large=temp("tximport/transcripts2genes.tsv"),
            gene2gene_large=temp("tximport/gene2gene.tsv")
        message: "Building transcripts/genes conversion table"
        cache: True
        threads: 1
        resources:
            mem_mb=lambda wildcards, attempt: attempt * 2048,
            time_min=lambda wildcards, attempt: attempt * 45
        params:
            gencode = True,
            header = True,
            positions = True
        log:
            "logs/tximport/tx2gene.log"
        wrapper:
            "bio/gtf/tx2gene"

    ######################
    ### Design parsing ###
    ######################


    rule split_design:
        input:
            design=config["design"]["path"],
        output:
            expand(
                "deseq2/designs/{comparison}.tsv",
                comparison=config["output_prefixes"]
            )
        message:
            "Expanding design in order to make results more readeble"
        threads: 1
        resources:
            mem_mb=lambda wildcards, attempt: attempt * 1024,
            time_min=lambda wildcards, attempt: attempt * 10
        log:
            "logs/deseq2/split_design.log"
        params:
            columns_to_aggregate=config["design"].get("aggregate_col"),
            columns_to_remove=config["design"].get("remove_col")
        wrapper:
            "bio/BiGR/split_design"

Note that input, output and log file paths can be chosen freely, as long as the dependencies between the rules remain as listed here.
For additional parameters in each individual wrapper, please refer to their corresponding documentation (see links below).

When running with

.. code-block:: bash

    snakemake --use-conda

the software dependencies will be automatically deployed into an isolated environment before execution.



Used wrappers
---------------------

The following individual wrappers are used in this meta-wrapper:


* :ref:`bio/rbt/csvreport`

* :ref:`bio/gtf/tx2gene`

* :ref:`bio/BiGR/split_design`

* :ref:`bio/tximport`

* :ref:`bio/deseq2/DESeqDataSetFromTximport`

* :ref:`bio/deseq2/DESeq`

* :ref:`bio/pandas/deseq2_to_gseaapp`


Please refer to each wrapper in above list for additional configuration parameters and information about the executed code.






Notes
-----

The R statistical formula must refer to columns in design file.




Authors
-------


* Thibault Dayris

