.. _`bio/biseq`:

BISEQ
=====

Analyse differentially methylated regions with BiSeq

**URL**: 

Example
-------

This wrapper can be used in the following way:

.. code-block:: python

    rule test_biseq:
        input:
            bismark = ["path/to/bismark"],
            coldata = "path/to/coldata.tsv"
        output:
            covboxplot = "path/to/covboxplot.png",
            raw = "path/to/biseq.RDS",
            clustersites = "path/to/clustered_sites.tsv",
            smooth_covboxplot = "path/to/smoothed_covboxplot.png",
            groupwise_scatterplot = "path/to/scatterplot.png",
            beta = "path/to/beta.regression.tsv"
        params:
            perc_samples = 4/5,
             min_sites = 20,
             max_dist = 100,
             bandwidth = 80,
             grid_dist = None,
             formula = "~group",
             link = "probit"

Note that input, output and log file paths can be chosen freely.

When running with

.. code-block:: bash

    snakemake --use-conda

the software dependencies will be automatically deployed into an isolated environment before execution.

Software dependencies
---------------------

* ``bioconductor-biseq==1.32.0``

Input/Output
------------
**Input:**

* ``bismark``: CpG contextx from methylation extractor of bismark

**Output:**

* ``beta``: TSV formatted table containing differentially methylated clusters
* ``raw``: Optional RDS-formatted BSraw object
* ``covboxplot``: Optional boxplot of the coverage of CpG-sites
* ``clustersites``: Optional table containing high density CpG cluster of regions
* ``smooth_covboxplot``: Optional boxplot of the coverage of smoothed CpG-sites
* ``groupwise_scatterplot``: Optional scatter plot giving the methilation level across two groups




Notes
-----

notes



Authors
-------

* Thibault Dayris


Code
----

.. code-block:: R

    #!/usr/bin/R

    base::library(package="BiSeq", quietly=TRUE);



    # Graphical parameters
    w <- 1024;
    if ("w" %in% base::names(snakemake@params)) {
      w <- base::as.numeric(snakemake@params[["w"]]);
    }
    h <- 768;
    if ("h" %in% base::names(snakemake@params)) {
      h <- base::as.numeric(snakemake@params[["h"]]);
    }

    # Convert input file path to string
    files <- sapply(
      snakemake@input[["bismark"]],
      function(p) base::as.character(x=p)
    );
    base::print(head(files));

    # Import bismark into R
    coldata <- utils::read.table(
      base::as.character(x=snakemake@input[["coldata"]]),
    );
    row.names(coldata) <- coldata$Sample_id
    base::print(head(coldata));

    rrbs <- BiSeq::readBismark(
      files=base::as.data.frame(files),
      colData=coldata
    );
    base::print(head(rowRanges(rrbs)));
    base::message("CpG results from bismark loaded");

    # Optional coverage and quality controls
    if ("covboxplot" %in% base::names(snakemake@output)) {
      covboxplot_path <- base::as.character(x = snakemake@output[["covboxplot"]]);

      png(
        filename = covboxplot_path,
        width = w,
        height = h,
        units = "px",
        type = "cairo"
      );

      BiSeq::covBoxplots(object=rrbs, col = "cornflowerblue", las = 2)

      dev.off();
      base::message("covBoxplot saved");
    }

    # Optional RDS base object
    if ("raw" %in% base::names(snakemake@output)) {
      utils::saveRDS(rrbs, file=base::as.character(x=snakemake@output[["raw"]]));
    }


    # Find BS clusters
    group_name <- "groups";
    if ("groups" %in% base::names(snakemake@params)) {
      group_name <- base::as.character(x=snakemake@params[["groups"]]);
    }
    groups <- colData(rrbs)[[group_name]];

    perc_samples <- 4/5;
    if ("perc_samples" %in% base::names(snakemake@params)) {
      perc_samples <- base::as.character(x=snakemake@params[["perc_samples"]]);
    }

    min_sites <- 20;
    if ("min_sites" %in% base::names(snakemake@params)) {
      min_sites <- base::as.character(x=snakemake@params[["min_sites"]]);
    }

    max_dist <- 100;
    if ("max_dist" %in% base::names(snakemake@params)) {
      max_dist <- base::as.character(x=snakemake@params[["max_dist"]]);
    }

    rrbs_clust_unlim <- BiSeq::clusterSites(
      object=rrbs,
      groups=groups,
      perc.samples=perc_samples,
      min.sites=min_sites,
      max.dist=max_dist
    );

    # Optional cluster sites table
    if ("clustersites" %in% base::names(snakemake@output)) {
      clusters_sites <- base::as.data.frame(rowRanges(rrbs_clust_unlim));

      utils::write.table(
        x=clusters_sites,
        file=base::as.character(x=snakemake@output[["clustersites"]]),
        quote=FALSE,
        sep="\t",
        col.names=TRUE,
        row.names=FALSE
      );
    }

    # Filter
    ind_cov <- totalReads(rrbs_clust_unlim) > 0;
    quant <- quantile(totalReads(rrbs_clust_unlim)[ind_cov], 0.9);
    rrbs_clust_lim <- limitCov(object=rrbs_clust_unlim, maxCov = quant);

    if ("smooth_covboxplot" %in% base::names(snakemake@output)) {
      covboxplot_path <- base::as.character(
        x = snakemake@output[["smooth_covboxplot"]]
      );

      png(
        filename = covboxplot_path,
        width = w,
        height = h,
        units = "px",
        type = "cairo"
      );

      BiSeq::covBoxplots(object=rrbs_clust_lim, col = "cornflowerblue", las = 2)

      dev.off();
    }

    # Predict methylation levels
    bandwidth <- 80;
    if ('bandwidth' %in% base::names(snakemake@params)) {
      bandwidth <- snakemake@params[["bandwidth"]];
    }

    grid_dist <- NULL;
    if ("grid_dist" %in% base::names(snakemake@params)) {
      grid_dist <- snakemake@params[["grid_dist"]];
    }

    predictedMeth <- BiSeq::predictMeth(
      object=rrbs_clust_lim,
      h=bandwidth,
      grid_dist=grid_dist,
      mc.cores=snakemake@threads
    );

    # Optionally plot groupwise scatterplot
    if ("groupwise_scatterplot" %in% base::names(snakemake@params)) {
      levels <- unique(coldata[[groups]]);
      left <- predictedMeth[, colData(predictedMeth)[[groups]] == levels[1]];
      right <- predictedMeth[, colData(predictedMeth)[[groups]] == levels[2]];
      mean_left <- rowMeans(methLevel(left));
      mean_right <- rowMeans(methLevel(right));

      groupwise_scatterplot_path <- base::as.character(
        x = snakemake@output[["groupwise_scatterplot"]]
      );

      png(
        filename = groupwise_scatterplot_path,
        width = w,
        height = h,
        units = "px",
        type = "cairo"
      );

      plot(
        mean_left,
        mean_right,
        col="blue",
        xlab=base::paste("Methylation in", levels[1], sep=" "),
        ylab=base::paste("Methylation in", levels[2], sep=" ")
      )

      dev.off();
    }

    # Fit beta model
    formula <- base::as.formula("~groups");
    if ("formula" %in% base::names(snakemake@params)) {
      formula <- base::as.formula(snakemake@params[["formula"]]);
    }

    link <- "probit";
    if ("link" %in% base::names(snakemake@params)) {
      link <- base::as.character(x=snakemake@params[["link"]]);
    }

    beta_results <- BiSeq::betaRegression(
      formula=formula,
      link=link,
      object=predictedMeth,
      mc.cores=snakemake@threads,
      type="BR"
    );

    utils::write.table(
      x=beta_results,
      file=base::as.character(x=snakemake@output[["beta"]]),
      quote=FALSE,
      sep="\t",
      col.names=TRUE,
      row.names=FALSE
    );


.. |nl| raw:: html

   <br>