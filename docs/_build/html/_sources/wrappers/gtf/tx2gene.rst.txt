.. _`bio/gtf/tx2gene`:

TX2GENE
=======

Build a transcript / gene correspondancy table from a GTF


Example
-------

This wrapper can be used in the following way:

.. code-block:: python

    rule tx_to_gene:
        input:
            gtf = "file.gtf"
        output:
            tx2gene = "tx2gene.tsv",
            tx2gene_large = "tx2gene_with_positions.tsv",
            gene2gene = "gene2gene.tsv",
            gene2gene_large = "gene2gene_with_chr.tsv"
        message:
            "Testing tx_to_gene"
        threads:
            1
        resources:
            mem_mb = (
                lambda wildcards, attempt: min(attempt * 512, 1024)
            ),
            time_min = (
                lambda wildcards, attempt: min(attempt * 10, 15)
            )
        log:
            "logs/tx_to_gene.log"
        wrapper:
            "0.72.0-574-gb9a1b13c8/bio/gtf/tx2gene"

Note that input, output and log file paths can be chosen freely.
When running with

.. code-block:: bash

    snakemake --use-conda

the software dependencies will be automatically deployed into an isolated environment before execution.

Software dependencies
---------------------

* ``conda-forge:python=3.9.0``
* ``conda-forge:pandas=1.1.4``

Input/Output
------------
**Input:**

* A path to a GTF file

**Output:**

* A TSV-formatted text file containing all transcript with their gene name



Notes
-----

Parameters:

* header (bool): Weather to write column header or not
* positions (bool): Weather to write positions or not
* gencode (bool): Remove patch in ensembl identifiers

The output file contains:

+--------+--------------+----------+------------+----------+----------+
| GeneID | TranscriptID | GeneName | Chromosome | Start    | Stop     |
+========+==============+==========+============+==========+==========+
| Awlays | Always       | Always   | Optional   | Optional | Optional |
+--------+--------------+----------+------------+----------+----------+



Authors
-------

* Thibault Dayris


Code
----

.. code-block:: python

    #!/usr/bin/python3.8
    # conding: utf-8

    """
    This script extracts a tsv from a GTF. This tsv contains Gene_ID,
    transcript_id, Gene_Name. Optionaly, headers and positions can
    also be given.
    """

    __author__ = "Thibault Dayris"
    __copyright__ = "Copyright 2020, Thibault Dayris"
    __email__ = "thibault.dayris@gustaveroussy.fr"
    __license__ = "MIT"

    import logging
    import numpy
    import pandas


    logging.basicConfig(
        filename=snakemake.log[0],
        filemode="w",
        level=logging.DEBUG
    )


    def fill_empty(frame: pandas.DataFrame,
                   fill_col: str,
                   ref_col: str) -> pandas.DataFrame:
        """
        Fill NA and empty values in a frame
        """
        frame[fill_col] = [
            ref if ((fill is None) or (fill == numpy.NaN)) else fill
            for fill, ref in zip(frame[fill_col], frame[ref_col])
        ]
        return frame


    # Read GTF file
    gtf = pandas.read_csv(
        snakemake.input["gtf"],
        sep="\t",
        header = None,
        comment = "#",
        dtype = {
            0: "category",
            1: "category",
            2: "category",
            3: "uintc",
            4: "uintc",
            5: "category",
            6: "category",
            7: "category"
        },
        na_values = "."
    )
    gtf.columns = [
        "Chromosome", "source", "feature", "Start", "Stop",
        "confidence", "Strand", "frame", "annotation"
    ]
    gtf.set_index(
        ["Chromosome", "source", "Strand", "feature"],
        inplace = True
    )
    logging.debug("Head of the GTF file:")
    logging.debug(gtf.head())
    logging.info("GTF loaded")


    # Extract transcripts identifiers, gene identifiers and gene names
    gtf["Gene_ID"] = gtf["annotation"].str.extract(r"gene_id \"(\w+.\w+)\"")
    gtf["transcript_id"] = gtf["annotation"].str.extract(r"transcript_id \"(\w+.\w+)\"")
    gtf["Gene_Name"] = gtf["annotation"].str.extract(r"gene_name \"(\w+.\w+)\"")
    del gtf["annotation"]


    # Filter on transcripts to reduce the amound of data
    gtf[gtf.index.get_level_values("feature") == "transcript"]
    gtf.index = gtf.index.droplevel("feature")

    logging.debug("Head of the GTF file:")
    logging.debug(gtf.head())
    logging.info("GTF parsed")

    # Removing patches on identifiers
    drop_patches = snakemake.params.get("drop_patches", True)
    if drop_patches is True:
        gtf["Gene_ID"] = gtf["Gene_ID"].str.split(r"\.", expand=True)[0]
        gtf["transcript_id"] = gtf["transcript_id"].str.split(r"\.", expand=True)[0]


    # Save results and their subsets on demand
    if "tx2gene_small" in snakemake.output.keys():
        tmp = gtf.copy()
        tmp = tmp[["transcript_id", "Gene_ID"]]
        tmp = fill_empty(tmp.copy(), "Gene_ID", "transcript_id")
        tmp.drop_duplicates(inplace=True)
        tmp.to_csv(
            snakemake.output["tx2gene_small"],
            sep = "\t",
            index = False,
            header = False
        )
        logging.info("Tx2Gene table saved without gene names")

    if "tx2gene" in snakemake.output.keys():
        tmp = gtf.copy()
        tmp = tmp[["Gene_ID", "transcript_id", "Gene_Name"]]
        tmp.drop_duplicates(inplace=True)
        tmp = fill_empty(tmp.copy(), "Gene_ID", "transcript_id")
        tmp = fill_empty(tmp.copy(), "Gene_Name", "Gene_ID")
        tmp.to_csv(
            snakemake.output["tx2gene"],
            sep = "\t",
            index = False,
            header = False
        )
        logging.info("Tx2Gene table saved")

    if "tx2gene_large" in snakemake.output.keys():
        tmp = gtf.copy()
        tmp = tmp[["Gene_ID", "transcript_id", "Gene_Name", "Start", "Stop"]]
        tmp = fill_empty(tmp.copy(), "Gene_ID", "transcript_id")
        tmp = fill_empty(tmp.copy(), "Gene_Name", "Gene_ID")
        tmp.drop_duplicates(inplace=True)
        tmp.to_csv(
            snakemake.output["tx2gene_large"],
            sep = "\t",
            index = True,
            header = True
        )
        logging.info("Tx2Gene table saved with positions and source info")

    if "gene2gene" in snakemake.output.keys():
        tmp = gtf.copy()
        tmp = tmp[["Gene_ID", "Gene_Name"]]
        tmp = fill_empty(tmp.copy(), "Gene_Name", "Gene_ID")
        tmp.drop_duplicates(inplace=True)
        tmp.to_csv(
            snakemake.output["gene2gene"],
            sep = "\t",
            index = False,
            header = False
        )
        logging.info("Gene2Gene table saved")


    if "gene2gene_large" in snakemake.output.keys():
        tmp = gtf.copy()
        tmp = tmp[["Gene_ID", "Gene_Name"]]
        tmp = fill_empty(tmp.copy(), "Gene_Name", "Gene_ID")
        tmp.drop_duplicates(inplace=True)
        tmp.to_csv(
            snakemake.output["gene2gene_large"],
            sep = "\t",
            index = True,
            header = True
        )
        logging.info("Gene2Gene table saved with Chromosome and source info")
