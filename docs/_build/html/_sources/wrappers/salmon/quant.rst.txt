.. _`bio/salmon/quant`:

SALMON_QUANT
============

Quantify transcripts with salmon 



Example
-------

This wrapper can be used in the following way:

.. code-block:: python

    rule salmon_quant_reads:
        input:
            # If you have multiple fastq files for a single sample (e.g. technical replicates)
            # use a list for r1 and r2.
            r1 = "reads/{sample}_1.fq.gz",
            r2 = "reads/{sample}_2.fq.gz",
            index = "salmon/transcriptome_index"
        output:
            quant = 'salmon/{sample}/quant.sf',
            lib = 'salmon/{sample}/lib_format_counts.json'
        log:
            'logs/salmon/{sample}.log'
        params:
            # optional parameters
            libtype ="A",
            #zip_ext = bz2 # req'd for bz2 files ('bz2'); optional for gz files('gz')
            extra=""
        threads: 2
        wrapper:
            "0.68.0-392-gc94c17c08/bio/salmon/quant"

Note that input, output and log file paths can be chosen freely.
When running with

.. code-block:: bash

    snakemake --use-conda

the software dependencies will be automatically deployed into an isolated environment before execution.

Software dependencies
---------------------

* ``salmon==1.4.0``

Input/Output
------------
**Input:**

* assembly index, fastq files

**Output:**

* quantification files




Authors
-------

* Tessa Pierce


Code
----

.. code-block:: python

    """Snakemake wrapper for Salmon Quant"""

    __author__ = "Tessa Pierce"
    __copyright__ = "Copyright 2018, Tessa Pierce"
    __email__ = "ntpierce@gmail.com"
    __license__ = "MIT"

    from os import path
    from snakemake.shell import shell


    def manual_decompression(reads, zip_ext):
        """Allow *.bz2 input into salmon. Also provide same
        decompression for *gz files, as salmon devs mention
        it may be faster in some cases."""
        unzip_tools = {
            "bz2": "bunzip2",
            "gz": "gunzip"
        }
        try:
            unzip_cmd = "<({} -c {})".format(unzip_tools[zip_ext], reads)
        except KeyError:
            unzip_cmd = reads

        return unzip_cmd


    extra = snakemake.params.get("extra", "")
    log = snakemake.log_fmt_shell(stdout=False, stderr=True)
    zip_ext = snakemake.params.get("zip_extension", "")

    # If user enableled the inline decompression, then one threads is reserved for
    # this purpose, and cannot be given to Snakemake.
    salmon_threads = snakemake.threads
    if zip_ext != "":
        if snakemake.threads < 2:
            raise ValueError("At lease 2 threads are required for this wrapper")
        salmon_threads = snakemake.threads - 1

    libtype = snakemake.params.get("libtype", "A")


    # Checking IO files
    r1 = snakemake.input.get("r1")
    r2 = snakemake.input.get("r2")
    r = snakemake.input.get("r")

    if r1 is not None and r2 is not None:
        r1 = (
            [snakemake.input.r1]
            if isinstance(snakemake.input.r1, str)
            else snakemake.input.r1
        )
        r2 = (
            [snakemake.input.r2]
            if isinstance(snakemake.input.r2, str)
            else snakemake.input.r2
        )
        if len(r1) != len(r2):
            raise ValueError(
                "input-> equal number of files required for r1 and r2"
            )

        r1_cmd = " --mates1 {}".format(manual_decompression(" ".join(r1), zip_ext))
        r2_cmd = " --mates2 {}".format(manual_decompression(" ".join(r2), zip_ext))
        read_cmd = " ".join([r1_cmd, r2_cmd])
    elif r is not None:
        r = (
            [snakemake.input.r]
            if isinstance(snakemake.input.r, str)
            else snakemake.input.r
        )
        read_cmd = " --unmatedReads " + manual_decompression(" ".join(r), zip_ext)
    else:
        raise ValueError(
            "Either r1 and r2 (paired), or r (unpaired) are required as input"
        )


    # Building output name from results
    outdir = path.dirname(snakemake.output.get("quant"))


    # Dealing with optional IO files
    if "gtf" in snakemake.input.keys():
        extra += " --geneMap {} ".format(snakemake.input["gtf"])

    if "mapping" in snakemake.output.keys():
        extra += " --writeMappings {} ".format(snakemake.output["mapping"])

    shell(
        "salmon quant --index {snakemake.input.index} "
        " --libType {libtype} {read_cmd} --output {outdir} "
        " --threads {salmon_threads} {extra} {log} "
    )
