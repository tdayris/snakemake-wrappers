.. _`bio/BiGR/copy`:

IGR_COPY
========

Copy/Softlink/concat files, either from an absolute path or iRODS ones.

**URL**: 

Example
-------

This wrapper can be used in the following way:

.. code-block:: python

    rule test_bigr_copy_single:
        output:
            "dest/file.txt"
        params:
            input="src/file.txt"
        wrapper:
            "0.76.0-805-g542e8c6a7/bio/BiGR/copy"


    rule test_bigr_copy_duo:
        output:
            "dest/file1.txt",
            "dest/file2.txt"
        params:
            input=["src/file1.txt", "src/file2.txt"]
        wrapper:
            "0.76.0-805-g542e8c6a7/bio/BiGR/copy"


    rule test_bigr_copy_concat:
        output:
            "dest/file_concat.txt"
        params:
            input=["src/file1.txt,src/file2.txt"]
        wrapper:
            "0.76.0-805-g542e8c6a7/bio/BiGR/copy"


    rule test_bigr_copy_to_dir:
        output:
            directory("dest_dir")
        params:
            input=["src/file1.txt", "src/file2.txt"]
        wrapper:
            "0.76.0-805-g542e8c6a7/bio/BiGR/copy"

Note that input, output and log file paths can be chosen freely.

When running with

.. code-block:: bash

    snakemake --use-conda

the software dependencies will be automatically deployed into an isolated environment before execution.

Software dependencies
---------------------

* ``conda-forge::bash==5.0.018``
* ``conda-forge::python-irodsclient==0.8.6``

Input/Output
------------
**Input:**

* Optional source path to the copied file

**Output:**

* Destination path of the copied file




Notes
-----

iRODS paths should be provided in parameters.

Give either a python list of paths to have separate files at the end, or
a comma separated list of files to concatenate each of them!



Authors
-------

* Thibault Dayris


Code
----

.. code-block:: python

    #!/usr/bin/python3.7
    # -*- coding: utf-8 -*-

    """Snakemake wrapper for bash copy within the IGR's Flamingo cluster"""

    __author__ = "Thibault Dayris"
    __copyright__ = "Copyright 2019, Thibault Dayris"
    __email__ = "thibault.dayris@gustaveroussy.fr"
    __license__ = "MIT"

    import os.path as op

    from snakemake.shell import shell
    from tempfile import TemporaryDirectory


    # Prepare logging
    log = snakemake.log_fmt_shell(stdout=False, stderr=True, append=True)
    extra_cp = snakemake.params.get("extra", "-v")
    extra_iget = snakemake.params.get("extra_irods", "-vK")


    # No node can access a cold storage
    # these files must be copied. However,
    # any file else where should be symlinked!
    cold_storage = (
        "/mnt/isilon",
        "/mnt/archivage",
        "/mnt/install"
    )


    def cat_files(dest: str, *src: str, log: str = log) -> None:
        shell(f"cat {' '.join(src)} > {dest} {log}")


    def bash_copy(src: str,
                  dest: str,
                  extra: str = extra_cp,
                  log: str = log,
                  cold: str = cold_storage) -> None:
        if src.startswith(cold) and ("--symbolic-link" not in extra):
            extra += " --symbolic-link"
        shell(f"cp {extra} {src} {dest} {log}")


    def iRODS_copy(src: str,
                   dest: str,
                   extra: str = extra_iget,
                   log: str = log) -> None:
        shell(f"iget {extra} {src} {dest} {log}")


    def copy(src: str, dest: str) -> None:
        if src.startswith("/odin/kdi/dataset/"):
            iRODS_copy(src, dest)
        else:
            bash_copy(src, dest)


    def copy_then_concat(dest: str, *src: str) -> None:
        with TemporaryDirectory() as tmpdir:
            outfiles = []
            for path in src:
                copy(path, tmpdir)
                outfiles.append(op.join(tmpdir, op.basename(path)))
            cat_files(dest, *outfiles)


    def copy_or_concat(src: str, dest: str) -> None:
        if "," in src:
            copy_then_concat(dest, *src.split(","))
        else:
            copy(src, dest)


    output_directory = op.realpath(op.dirname(snakemake.output[0]))

    sources = snakemake.params.get("input", snakemake.input)

    if len(destinations := snakemake.output) == 1:
        # Then there is only one directory as a destination
        destination = op.realpath(str(destinations))
        shell(f"mkdir --parents --verbose {op.dirname(destination)} {log}")
        if isinstance(sources, str):
            copy_or_concat(sources, destination)
        else:
            for source in sources:
                copy_or_concat(source, destination)
    elif len(sources) == len(destinations):
        # Then there muse be as many paths as source
        for source, destination in zip(sources, destinations):
            shell(f"mkdir --parents --verbose {op.dirname(destination)} {log}")
            copy_or_concat(source, destination)
    else:
        print(len(sources), len(destinations), sources, destinations)
        raise ValueError("Number of input and output paths do not match.")
