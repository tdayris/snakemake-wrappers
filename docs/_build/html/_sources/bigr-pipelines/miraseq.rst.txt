.. _`MiraSeq`:

MIRASEQ
=======

Analyse methylation enrichment on MIRA-Seq with biskmark

Usage
-----

In order to run the pipeline, use the following commands

.. code-block:: bash 

  # Go to your working directory

  cd /path/to/my/working/directory

  # Build a design file (see below)

  # Copy/paste the following line for **HG19**

  bash /mnt/beegfs/pipelines/snakemake-wrappers/bigr_pipelines/miraseq/run.sh hg19

  # Copy/paste the following line for **HG38**

  bash /mnt/beegfs/pipelines/snakemake-wrappers/bigr_pipelines/miraseq/run.sh hg38


Input/Output
------------


**Input:**

 
  
* Pair of fastq files
  
 
  
* Fasta-formatted genome sequence
  
 


**Output:**

 
  
* Bam-formatted mapped reads
  
 
  
* Methylation reports per sample
  
 





Used meta-wrappers
------------------

The following individual meta-wrappers are used in this pipeline:


* :ref:`meta/bio/bismark`


Please refer to each meta-wrapper in above list for additional configuration parameters and information about the executed code.




Used wrappers
-------------

The following individual wrappers are used in this pipeline:


* :ref:`bio/fastp`

* :ref:`bio/BiGR/copy`


Please refer to each wrapper in above list for additional configuration parameters and information about the executed code.






Snakefile
---------

The pipeline contains the following steps:

.. code-block:: python

    from snakemake.utils import min_version
    from pathlib import Path
    from yaml import dump
    min_version("6.0")

    import sys

    worflow_source_dir = Path(snakemake.workflow.srcdir("."))
    common = str(worflow_source_dir / ".." / "common" / "python")
    sys.path.append(common)

    from dataframes import *
    from file_manager import *
    from files_linker import *
    from graphics import *
    from write_yaml import *
    from messages import message


    #################
    ### Preambule ###
    #################

    logging.basicConfig(
        filename="snakemake.miraseq.log",
        filemode="w",
        level=logging.DEBUG
    )

    default_config = read_yaml(worflow_source_dir / "config.hg38.yaml")
    configfile: get_config(default_config)
    design = get_design(os.getcwd(), search_fastq_files_dict)

    fastq_links = {}
    if config["params"].get("Paired", False) is True:
        fastq_links = link_fq(
            design.Sample_id,
            design.Upstream_file,
            design.Downstream_file
        )
    else:
            fastq_links = link_fq(
            design.Sample_id,
            design.Upstream_file
        )


    ruleorder: bismark_methylation_extractor_se_multisample > bismark_methylation_extractor_pe_multisample

    ##############
    ### Target ###
    ##############

    rule target:
        input:
            # bismark=expand(
            #     "bismark/report/{sample}.SE.html",
            #     sample=design["Sample_id"].tolist()
            # ),
            multiqc="results/MiraSeq.html",
            #multisample_cov="bismark_multisample/meth_cpg/multisample.bismark.cov.gz",
            #multisample_report='bismark_multisample/meth/multisample_SE_splitting_report.txt'


    ####################################
    ### FastQ Screen and MultiQC     ###
    ####################################


    rule multiqc:
        input:
            html=expand(
                "fastp/html/pe/{sample}.fastp.html",
                sample=design["Sample_id"]
            ),
            json=expand(
                "fastp/json/pe/{sample}.fastp.json",
                sample=design["Sample_id"]
            ),
            txt=expand(
                "fastq_screen/{sample}.fastq_screen.txt",
                sample=design["Sample_id"],
                stream=["1", "2"]
            ),
            png=expand(
                "fastq_screen/{sample}.fastq_screen.png",
                sample=design["Sample_id"],
                stream=["1", "2"]
            ),
            mapping_qc=expand(
                "stats/{sample}{ext}",
                sample=design["Sample_id"],
                ext=[
                    ".alignment_summary_metrics",
                    #".insert_size_metrics",
                    #".insert_size_histogram.pdf",
                    ".quality_distribution_metrics",
                    ".quality_distribution.pdf",
                    #".quality_by_cycle_metrics",
                    #".quality_by_cycle.pdf",
                    #".base_distribution_by_cycle_metrics",
                    #".base_distribution_by_cycle.pdf",
                    ".gc_bias.detail_metrics",
                    ".gc_bias.summary_metrics",
                    ".gc_bias.pdf",
                    #".rna_metrics",
                    #".bait_bias_detail_metrics",
                    #".bait_bias_summary_metrics",
                    #".error_summary_metrics",
                    #".pre_adapter_detail_metrics",
                    #".pre_adapter_summary_metrics",
                    #".quality_yield_metrics"
                ]
            )
            # bismark_alignment_report=expand(
            #     "bismark/bams/{sample}_SE_report.txt",
            #     sample=design["Sample_id"].tolist()
            # ),
            # bismark_nucleotide_report=expand(
            #     "bismark/bams/{sample}.SE.nucleotide_stats.txt",
            #     sample=design["Sample_id"].tolist()
            # ),
            # bismark_dedup_report=expand(
            #     "bismark/deduplicated/{sample}.SE.deduplication_report.txt",
            #     sample=design["Sample_id"].tolist()
            # ),
            # bismark_mbias_report=expand(
            #     "bismark/meth/{sample}.SE.M-bias.txt",
            #     sample=design["Sample_id"].tolist()
            # ),
            # bismark_splitting_report=expand(
            #     "bismark/meth/{sample}_SE_splitting_report.txt",
            #     sample=design["Sample_id"].tolist()
            # )
        output:
            report(
                "results/MiraSeq.html",
                caption="../common/reports/multiqc.rst",
                category="Quality Controls"
            )
        message:
            "Aggregating quality reports from Fastp and Salmon"
        threads: 1
        resources:
            mem_mb=lambda wildcards, attempt: min(attempt * 1536, 10240),
            time_min=lambda wildcards, attempt: attempt * 35
        log:
            "logs/multiqc.log"
        wrapper:
            "bio/multiqc"


    rule fastq_screen:
        input:
            "reads/{sample}.fq.gz"
        output:
            txt="fastq_screen/{sample}.fastq_screen.txt",
            png="fastq_screen/{sample}.fastq_screen.png"
        message:
            "Assessing quality of {wildcards.sample}"
        threads: config.get("threads", 20)
        resources:
            mem_mb=lambda wildcard, attempt: attempt * 1024 * 8,
            time_min=lambda wildcard, attempt: attempt * 50
        params:
            fastq_screen_config=config["fastq_screen"],
            subset=100000,
            aligner='bowtie2'
        log:
            "logs/fastq_screen/{sample}.log"
        wrapper:
            "bio/fastq_screen"


    #####################
    ### Methylation ? ###
    #####################


    bismark_config = {
        "genome": config["ref"]["genome"],
        "paired": config["params"].get("Paired", True),
        "samples": design["Sample_id"].tolist()
    }

    module bismark:
        snakefile: "../../meta/bio/bismark/test/Snakefile"
        config: bismark_config


    use rule * from bismark as *


    module bismark_multisample:
        snakefile: "../../meta/bio/bismark_multisample/test/Snakefile"
        config: bismark_config


    use rule * from bismark_multisample


    ################
    ###  Mapping ###
    ################

    rule collect_multiple_metrics:
        input:
             bam="samtools/sort/{sample}.bam",
             bam_index="samtools/sort/{sample}.bam.bai",
             ref=config["ref"]["genome"]
        output:
            multiext("stats/{sample}",
                     ".alignment_summary_metrics",
                     #".insert_size_metrics",
                     #".insert_size_histogram.pdf",
                     ".quality_distribution_metrics",
                     ".quality_distribution.pdf",
                     #".quality_by_cycle_metrics",
                     #".quality_by_cycle.pdf",
                     #".base_distribution_by_cycle_metrics",
                     #".base_distribution_by_cycle.pdf",
                     ".gc_bias.detail_metrics",
                     ".gc_bias.summary_metrics",
                     ".gc_bias.pdf",
                     #".rna_metrics",
                     #".bait_bias_detail_metrics",
                     #".bait_bias_summary_metrics",
                     #".error_summary_metrics",
                     #".pre_adapter_detail_metrics",
                     #".pre_adapter_summary_metrics",
                     #".quality_yield_metrics"
                     )
        threads: 1
        resources:
            mem_mb=lambda wildcards, attempt: attempt * 1024 * 8,
            time_min=lambda wildcards, attempt: attempt * 45,
            tmpdir="tmp"
        log:
            "logs/picard/multiple_metrics/{sample}.log"
        params:
            #"VALIDATION_STRINGENCY=LENIENT "
            #"METRIC_ACCUMULATION_LEVEL=null "
            #"METRIC_ACCUMULATION_LEVEL=SAMPLE "
        wrapper:
            "bio/picard/collectmultiplemetrics"

    config_bwa_fixmate = {
        "threads": 20,
        "genome": config["ref"]["genome"]
    }

    module bwa_fixmate:
        snakefile: "../../meta/bio/bwa_fixmate/test/Snakefile"
        config: config_bwa_fixmate

    use rule * from bwa_fixmate

    use rule bwa_mem from bwa_fixmate with:
        input:
            reads = "fastp/trimmed/pe/{sample}.fastq",
            index=multiext(
                "bwa_mem2/index/genome", ".0123", ".amb", ".ann", ".pac"
            )


    ############################
    ### FASTP FASTQ CLEANING ###
    ############################

    rule fastp_clean:
        input:
            sample=["reads/{sample}.fq.gz"]
        output:
            trimmed=temp("fastp/trimmed/pe/{sample}.fastq"),
            html="fastp/html/pe/{sample}.fastp.html",
            json=temp("fastp/json/pe/{sample}.fastp.json")
        message: "Cleaning {wildcards.sample} with Fastp"
        threads: 1
        resources:
            mem_mb=lambda wildcards, attempt: min(attempt * 4096, 15360),
            time_min=lambda wildcards, attempt: attempt * 45
        params:
            adapters=config["params"].get("fastp_adapters", None),
            extra=config["params"].get("fastp_extra", "")
        log:
            "logs/fastp/{sample}.log"
        wrapper:
            "bio/fastp"


    #################################################
    ### Gather files from iRODS or mounting point ###
    #################################################

    rule bigr_copy:
        output:
            "reads/{sample}.fq.gz"
        message:
            "Gathering {wildcards.sample} fastq file"
        threads: 1
        resources:
            mem_mb=lambda wildcards, attempt: min(attempt * 1024, 2048),
            time_min=lambda wildcards, attempt: attempt * 45
        params:
            input=lambda wildcards, output: fastq_links[output[0]]
        log:
            "logs/bigr_copy/{sample}.log"
        wrapper:
            "bio/BiGR/copy"




Authors
-------


* Thibault Dayris
