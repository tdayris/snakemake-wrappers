.. _`dge_deseq2`:

DGE_DESEQ2
==========

Perform trimming and quantification on RNASeq

Usage
-----

In order to run the pipeline, use the following commands

.. code-block:: bash 

  # Go to your working directory

  cd /path/to/my/working/directory

  # Build a design file (see below)

  # Copy/paste the following line for **HG19**

  bash /mnt/beegfs/pipelines/snakemake-wrappers/bigr_pipelines/dge_deseq2/run.sh hg19

  # Copy/paste the following line for **HG38**

  bash /mnt/beegfs/pipelines/snakemake-wrappers/bigr_pipelines/dge_deseq2/run.sh hg38


Input/Output
------------


**Input:**

 
  
* Fastq files
  
 
  
* Fasta-formatted Genome sequence
  
 
  
* Fasta-formatted transcriptome sequence
  
 
  
* GTF formatted genome annotation
  
 


**Output:**

 
  
* Salmon quantification
  
 
  
* Quality controls
  
 
  
* Trimmed fastq files
  
 







Notes
-----

Prerequisites:

* A TSV formatted design file, *named 'design.tsv'* with the following columns:

.. list-table:: Desgin file format
  :widths: 33 33 33
  :header-rows: 1

  * - Sample_id
    - Upstream_fastq
    - Downstream_fastq
  * - Name of the Sample1
    - Path to upstream fastq file
    - Path to downstream fastq file
  * - Name of the Sample2
    - Path to upstream fastq file
    - Path to downstream fastq file
  * - ...
    - ...
    - ...


How doas it work ?

1. Salmon quantification

You name it! It's the salmon_quant pipeline itself. I won't copy-paste all
it explanations around here, click on salmon_quant on the left panel and see
you here right after.

2. Aggregation

Based on the GTF annotation, the correspondancy between trnascripts
identifiers and gene names is written in a text table. This will later be
used for annotations and results descriptions.

TXimport is used to aggregate trnascript counts into gene ones. It also takes
bootstraps into account and build a DESeqDataset object with statistical
formula and experimental design included.

3. DESeq2

DESeq2 is run over all factor combinations (1 condition vs 1 other), for every
single possible comparisons. We use ENSG annotations in this step to avoid
duplicates in gene names. This would raise errors and lead to errors in the
result interpretations.

If you have more than 2 factors, this step can return A LOT of results. And
by A LOT, I speak about combinations and interpolations. Example: with 2
factors (WT and KO) and 2 status (Treated and Untreated), then 6 comparisons
are computed. If you add a single batch effect, then up to 28 comparisons can
be computed. Most of the time, only one or two of them are usefull.

Look at the results names or filter them!

You may modify your config-file to auto-filter results. Note the head of your
config-file. It starts with `design: path: design.tsv`. On the same level as
`path` add a new key named `include_only` to include results with a given
list of words in it. Example: with 2 factors (WT and KO) and 2 status
(Treated and Untreated). It want only WT_Untreated to be the reference. Then,
I add `include_only: ['WT_Untreated']` in the config file.

You may wan to "combine" two columns in your design file. Use
`aggregate_col: [["factor1", "factor2"]]` to combine them. Example: with 2
factors (WT and KO) and 2 status (Treated and Untreated). I would write:
`aggregate_col: [["factor", "status"]]` on the same level as `path`.

4. Post processing: TSV

DESeq2 results are not usefull for a fellow biologists. They are annotated by
in-house scripts. Gene names are added, pvalues are filtered, counts are
merged and results are sorted around the two most asked ranks.

Differential expression satus is also written in full letters, as well as the
expression change.

5. Post processing: PNG

DESeq2 objects are not usefull for fellow biologists. Most of them do not use
R/Python on a daily basis and it is completely normal. Clustering, MAPlots,
Volcanoplots and many others are build and aggregated in a nice HTML page.

You may need special graphs over genes of interest. This may be to highlight
a differential expression or to understand why surch expression variation was
not statistically significant. Then use the key: `genes_of_interest` with a
list of genes on the same level as `design`.

6. Post processing: Quality controls

Additional quality controls are built for this pipeline. Most of them
are embedded in a HTML file with MultiQC. It also includes salmon_quant
quality controls!

Note that a MultiQC HTML report ships only the samples used in the comparison.
If a Sample should not belong to a given HTML report, then the design was
wrong to begin with...





Snakefile
---------

The pipeline contains the following steps:

.. code-block:: python

    from snakemake.utils import min_version
    from pathlib import Path
    from yaml import dump
    min_version("6.0")

    import sys

    worflow_source_dir = Path(next(iter(workflow.get_sources()))).absolute().parent
    common = str(worflow_source_dir / "../common/python")
    sys.path.append(common)

    from dataframes import *
    from file_manager import *
    from files_linker import *
    from graphics import *
    from write_yaml import *
    from messages import message


    #################
    ### Preambule ###
    #################

    logging.basicConfig(
        filename="snakemake.dge_deseq2.log",
        filemode="w",
        level=logging.DEBUG
    )

    default_config = read_yaml(worflow_source_dir / "config.hg38.yaml")
    configfile: get_config(default_config)

    try:
        design = pandas.read_csv("design.tsv", sep="\t", header=0, index_col=0)
        design["Sample_id"] = design.index.tolist()
        #design.set_index("Sample_id", inplace=True)
    except FileNotFoundError:
        logging.error(
            """A design file is required for this pipeline. It is a TSV with
            the following columns:

            1. Sample_id (case matters): Name of your sample, unique and composed
               with a least 1 letter (no sample should have numerical names only,
               it would make R fail while parsing sample names with DESeq2)
            2. Upstream_file (case matters): Path to the file, it can be
               an absolute path, a relative path, or a iRODS url.
            3. Downstream_file (case matters): Path to the file, it can be
               an absolute path, a relative path, or a iRODS url.
            4. XXXX: A name of your choice, unique and understandable. It will be
               used as comparison name within DESeq2 and graphs. It contains levels
               for each single sample. Do not use only integers or floats for your
               level name: R and DESeq2 behaves stangely with them.
            5. YYYY: A name of your choice, unique and understandable. It will be
               used as comparison name within DESeq2 and graphs. It contains levels
               for each single sample. Do not use only integers or floats for your
               level name: R and DESeq2 behaves stangely with them.
            Etc, etc. You can have any other condition name. Name them as you want,
            these names must be unique and understandable. It will be used as
            comparison name within DESeq2 and graphs. It contains levels for each
            single sample. Do not use only integers or floats for your level name:
            R and DESeq2 behaves stangely with them.
            """
        )

    try:
        fastq_links = link_fq(
            design.Sample_id,
            design.Upstream_file,
            design.Downstream_file
        )

        ruleorder: multiqc > multiqc_se
        ruleorder: salmon_quant > salmon_quant_se

    except AttributeError:
        fastq_links = link_fq(
            design.Sample_id,
            design.Upstream_file
        )

        ruleorder: multiqc_se > multiqc
        ruleorder: salmon_quant_se > salmon_quant

    # A list that holds all comparisons expected for this snakemake pipeline
    comparison_levels = list(yield_comps(
        complete_design=design,
        aggregate=config["design"].get("aggregate_col"),
        remove=config["design"].get("remove_col"),
        contains=config["design"].get("include_only")
    ))

    # Stored as a list for futrther re-use
    output_prefixes = [
        f"DGE_considering_factor_{factor}_comparing_{test}_vs_{ref}"
        for factor, test, ref in comparison_levels
    ]
    # print(output_prefixes)

    # An iterator that holds all samples involved in the comparisons
    # listed above
    samples_iterator = yield_samples(
        complete_design=design.copy(),
        aggregate=config["design"].get("aggregate_col"),
        remove=config["design"].get("remove_col")
    )



    expected_pcas = [
        f"figures/DGE_considering_factor_{factor}_comparing_{test}_vs_{ref}/pca/pca_{factor}_{axes}_{elipse}.png"
        for (factor, test, ref) in comparison_levels
        for axes in ["ax_1_ax_2", "ax_2_ax_3"] # , "ax_3_ax_4"]
        for elipse in ["with_elipse", "without_elipse"]
    ]

    condition_dict = {
        f"DGE_considering_factor_{factor}_comparing_{test}_vs_{ref}": relation_condition_sample(design.copy(), factor, test, ref)
        for factor, test, ref in comparison_levels
    }

    samples_per_prefixes = dict(zip(output_prefixes, condition_dict))
    samples_per_prefixes = {
        prefix: list(condition_dict[prefix].keys())
        for prefix in output_prefixes
    }
    logging.debug(samples_per_prefixes)
    # print(samples_per_prefixes)
    # print(condition_dict)


    ############################
    ### Wilcards constraints ###
    ############################

    wildcard_constraints:
        comparison=r"|".join(output_prefixes),
        factor=r"|".join(map(str, [i[0] for i in comparison_levels])),
        test=r"|".join(map(str, [i[1] for i in comparison_levels])),
        ref=r"|".join(map(str, [i[2] for i in comparison_levels])),
        axes=r"|".join(["ax_1_ax_2", "ax_2_ax_3", "ax_3_ax_4"]),
        elipse=r"|".join(["with_elipse", "without_elipse"])


    ###################
    ### Target rule ###
    ###################

    rule target:
        input:
            multiqc=expand(
                "results/{comparison}/MultiQC.{comparison}.html",
                comparison=output_prefixes
            ),
            gseaapp=expand(
                "results/{comparison}/deseq2_{subset}_{comparison}.tsv",
                comparison=output_prefixes,
                subset=["complete_results", "sorted_on_fold_change", "sorted_on_pval"]
            ),
            csv_report=expand(
                "results/{comparison}/html_table_deseq2_{subset}.tar.bz2",
                comparison=output_prefixes,
                subset=["complete_results", "sorted_on_fold_change", "sorted_on_pval"]
            ),
            deseq2_wald=expand(
                "deseq2/{comparison}/wald.{comparison}.RDS",
                comparison=output_prefixes
            ),
            pcas=expected_pcas,
            general_pcas=expand(
                "figures/pca/general.pca_{axes}.png",
                axes=["PC1_PC2", "PC2_PC1"]
            ),
            counts_with_deseq2=expand(
                "results/{comparison}/deseq2_{content}_with_counts_{comparison}.tsv",
                comparison=output_prefixes,
                content=["complete_results", "sorted_on_pval", "sorted_on_fold_change"]
            ),
            gene_plots=expand(
                "results/{comparison}/gene_plots/{gene}.png",
                comparison=output_prefixes,
                gene=config.get("genes_of_interest", ["ENSG00000141510"])
            )
            #consensus=expand(
            #    "consensusclusterplus/{comparison}",
            #    comparison=output_prefixes
            #)


    ##############################
    ### DESeq2 post processing ###
    ##############################


    deseq2_post_process_config = {
        "condition_dict": condition_dict,
        "samples_per_prefixes": samples_per_prefixes,
        "design": design.copy(),
        "thresholds": config["thresholds"],
        "genes_of_interest": config.get(
            "genes_of_interest", ["ENSG00000141510"]
        ),
        "chromosomes": config["ref"].get(
            "chromosomes",
            list(range(24)) + ["MT", "X", "Y"] + list(map(str, range(24)))
        )
    }


    module deseq2_post_process:
        snakefile: "../../meta/bio/deseq2_post_process/test/Snakefile"
        config: deseq2_post_process_config


    use rule * from deseq2_post_process as *

    use rule pandas_merge_salmon_tr from deseq2_post_process with:
        input:
            quant = expand(
                "salmon_quant/salmon/pseudo_mapping/{sample}/quant.sf",
                sample=design.Sample_id.tolist()
            ),
            tx2gene = "tximport/transcripts2genes.tsv"


    use rule multiqc from deseq2_post_process with:
        input:
            txt=lambda wildcards: expand(
                "salmon_quant/fastq_screen/{sample}.{stream}.fastq_screen.txt",
                sample=samples_per_prefixes[wildcards.comparison],
                stream=["1", "2"]
            ),
            png=lambda wildcards: expand(
                "salmon_quant/fastq_screen/{sample}.{stream}.fastq_screen.png",
                sample=samples_per_prefixes[wildcards.comparison],
                stream=["1", "2"]
            ),
            salmon=lambda wildcards: expand(
                "salmon_quant/salmon/pseudo_mapping/{sample}/quant.sf",
                sample=samples_per_prefixes[wildcards.comparison]
            ),
            html=lambda wildcards: expand(
                "salmon_quant/fastp/html/pe/{sample}.fastp.html",
                sample=samples_per_prefixes[wildcards.comparison]
            ),
            json=lambda wildcards: expand(
                "salmon_quant/fastp/json/pe/{sample}.fastp.json",
                sample=samples_per_prefixes[wildcards.comparison]
            ),
            config="multiqc/{comparison}/multiqc_config.yaml",
            fqscreen=lambda wildcards: expand(
                "salmon_quant/fastq_screen/{sample}.{stream}.fastq_screen.{ext}",
                stream=["1", "2"],
                ext=["txt", "png"],
                sample=samples_per_prefixes[wildcards.comparison]
            ),
            additional_plots = [
                #temp("pairwise_scatterplot_mqc.png"),
                #temp("clustermap_sample_mqc.png"),
                "multiqc/{comparison}/clustermap_sample_mqc.png",
                #"multiqc/{comparison}/clustermap_genes_mqc.png",
                "multiqc/{comparison}/pca_plot_mqc.png",
                "multiqc/{comparison}/volcanoplot_mqc.png",
                "multiqc/{comparison}/distro_expr_mqc.png",
                "multiqc/{comparison}/ma_plot_mqc.png",
                "multiqc/{comparison}/distro_mu_mqc.png",
                "multiqc/{comparison}/independent_filter_mqc.png",
                "multiqc/{comparison}/inde_theta_filter_mqc.png",
                "multiqc/{comparison}/pvalue_qc_mqc.png",
                #temp("multiqc/{comparison}/clustermap_sample_mqc.png"),
                #temp("pca_axes_correlation_mqc.png")
            ]


    use rule multiqc from deseq2_post_process as multiqc_se with:
        input:
            txt=lambda wildcards: expand(
                "salmon_quant/fastq_screen/{sample}.fastq_screen.txt",
                sample=samples_per_prefixes[wildcards.comparison]
            ),
            png=lambda wildcards: expand(
                "fastq_screen/{sample}.fastq_screen.png",
                sample=samples_per_prefixes[wildcards.comparison]
            ),
            salmon=lambda wildcards: expand(
                "salmon_quant/salmon/pseudo_mapping/{sample}/quant.sf",
                sample=samples_per_prefixes[wildcards.comparison]
            ),
            html=lambda wildcards: expand(
                "salmon_quant/fastp/html/pe/{sample}.fastp.html",
                sample=samples_per_prefixes[wildcards.comparison]
            ),
            json=lambda wildcards: expand(
                "salmon_quant/fastp/json/pe/{sample}.fastp.json",
                sample=samples_per_prefixes[wildcards.comparison]
            ),
            config="multiqc/{comparison}/multiqc_config.yaml",
            fqscreen=lambda wildcards: expand(
                "salmon_quant/fastq_screen/{sample}.fastq_screen.{ext}",
                ext=["txt", "png"],
                sample=samples_per_prefixes[wildcards.comparison]
            ),
            additional_plots = [
                #temp("pairwise_scatterplot_mqc.png"),
                #temp("clustermap_sample_mqc.png"),
                "multiqc/{comparison}/clustermap_sample_mqc.png",
                #"multiqc/{comparison}/clustermap_genes_mqc.png",
                "multiqc/{comparison}/pca_plot_mqc.png",
                "multiqc/{comparison}/volcanoplot_mqc.png",
                "multiqc/{comparison}/distro_expr_mqc.png",
                "multiqc/{comparison}/ma_plot_mqc.png",
                "multiqc/{comparison}/distro_mu_mqc.png",
                "multiqc/{comparison}/independent_filtering_mqc.png",
                "multiqc/{comparison}/theta_knee_plot_mqc.png",
                "multiqc/{comparison}/pvalue_qc.png",
                #temp("multiqc/{comparison}/clustermap_sample_mqc.png"),
                #temp("pca_axes_correlation_mqc.png")
            ]


    ###########################
    ### tximprot and DESeq2 ###
    ###########################

    deseq2_config = {
        "gtf": config["ref"]["gtf"],
        "design": config["design"],
        "output_prefixes": output_prefixes,
        "comparison_levels": comparison_levels,
        "samples_per_prefixes": samples_per_prefixes
    }


    module tximport_deseq2:
        snakefile: "../../meta/bio/tximport_deseq2/test/Snakefile"
        config: deseq2_config


    use rule * from tximport_deseq2

    use rule tximport from tximport_deseq2 with:
        input:
            quant=lambda wildcards: expand(
                "salmon_quant/salmon/pseudo_mapping/{sample}/quant.sf",
                sample=samples_per_prefixes[wildcards.comparison]
            ),
            tx_to_gene="tximport/tx2gene.tsv"


    #############################
    ### Salmon quantification ###
    #############################

    rule salmon_quant:
        input:
            design=ancient("design.tsv"),
            config=ancient("config.yaml")
        output:
            results=directory("salmon_quant/results_to_upload"),
            quant_genes=expand(
                "salmon_quant/salmon/pseudo_mapping/{sample}/quant.genes.sf",
                sample=design["Sample_id"]
            ),
            quant=expand(
                "salmon_quant/salmon/pseudo_mapping/{sample}/quant.sf",
                sample=design["Sample_id"]
            ),
            tx2gene="salmon_quant/salmon/tx2gene.tsv",
            html=temp(expand(
                "salmon_quant/fastp/html/pe/{sample}.fastp.html",
                sample=design["Sample_id"]
            )),
            json=expand(
                "salmon_quant/fastp/json/pe/{sample}.fastp.json",
                sample=design["Sample_id"]
            ),
            fastq_screen=temp(expand(
                "salmon_quant/fastq_screen/{sample}.{stream}.fastq_screen.{ext}",
                sample=design["Sample_id"],
                stream=["1", "2"],
                ext=["txt", "png"]
            )),
            quant_qc="salmon_quant/multiqc/MultiQC.html",
            quant_gene_table="salmon_quant/salmon/TPM.genes.tsv",
            quant_tr_table="salmon_quant/salmon/TPM.transcripts.tsv"
        message:
            "Quantifying mRNAs over gentrome"
        threads: 1
        handover: True
        resources:
            mem_mb=lambda wildcards, attempt: attempt * 1024 * 4,
            time_min=lambda wildcards, attempt: attempt * 60 * 4,
            tmpdir="tmp"
        log:
            "logs/salmon_quant_pipeline.log"
        params:
            ln="--symbolic --force --relative --verbose",
            mkdir="--parents --verbose",
            quant_dir="salmon_quant",
            pipeline_path="/mnt/beegfs/pipelines/snakemake-wrappers/bigr_pipelines/salmon_quant/run.sh",
            pipeline_params="--nt"
        shell:
            "(mkdir {params.mkdir} {params.quant_dir} && "
            "ln {params.ln} {input.design} {params.quant_dir} && "
            "ln {params.ln} {input.config} {params.quant_dir} && "
            "cd {params.quant_dir} && "
            "bash {params.pipeline_path} {params.pipeline_params}) # >> {log} 2>&1"


    use rule salmon_quant as salmon_quant_se with:
        output:
            results=directory("salmon_quant/results_to_upload"),
            quant_genes=expand(
                "salmon_quant/salmon/pseudo_mapping/{sample}/quant.genes.sf",
                sample=design["Sample_id"]
            ),
            quant=expand(
                "salmon_quant/salmon/pseudo_mapping/{sample}/quant.sf",
                sample=design["Sample_id"]
            ),
            tx2gene="salmon/tx2gene.tsv",
            html=temp(expand(
                "fastp/html/pe/{sample}.fastp.html",
                sample=design["Sample_id"]
            )),
            json=expand(
                "fastp/json/pe/{sample}.fastp.json",
                sample=design["Sample_id"]
            ),
            fastq_screen=temp(expand(
                "fastq_screen/{sample}.fastq_screen.{ext}",
                sample=design["Sample_id"],
                ext=["txt", "png"]
            )),
            quant_qc="salmon_quant/multiqc/MultiQC.html",
            quant_gene_table="salmon_quant/salmon/TPM.genes.tsv",
            quant_tr_table="salmon_quant/salmon/TPM.transcripts.tsv"




Authors
-------


* Thibault Dayris

* M boyba Diop

* Marc Deloger
